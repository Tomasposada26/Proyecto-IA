"""Recommender module for NEA backend.

This module provides a simple multimodal recommender system that combines
content‑based filtering with basic collaborative filtering signals.  It loads
items from a JSON database (generated by ``import_datasets.py``) and
pre‑computes TF–IDF representations of the textual fields for each item.

The recommender exposes methods to return the top recommendations based on
user preferences (gustos), retrieve the top items by rating, and list
available categories.  Although the term "multimodal" is used here, the
implementation focuses on combining textual similarity with numerical ratings.

To extend this module, you could integrate additional modalities such as
facial emotion vectors or train a proper collaborative filtering model.  The
current implementation is designed to be lightweight and self‑contained.
"""

from __future__ import annotations

import json
import os
from typing import Dict, List, Optional, Tuple

import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics.pairwise import cosine_similarity


class MultimodalRecommender:
    """A simple recommender system combining content and rating signals."""

    def __init__(self, db_path: str) -> None:
        self.db_path = db_path
        self.db: Dict[str, List[Dict]] = {}
        self.categories: List[str] = []
        self.vectorizer: Optional[TfidfVectorizer] = None
        self.tfidf_matrix: Optional[np.ndarray] = None
        self.rating_array: Optional[np.ndarray] = None
        self.items_index: List[Tuple[str, int]] = []  # (category, index_in_category)
        self._load_data()

    def _load_data(self) -> None:
        """Load the JSON database and build TF‑IDF and rating matrices."""
        if not os.path.exists(self.db_path):
            raise FileNotFoundError(f"Database file not found: {self.db_path}")
        with open(self.db_path, "r", encoding="utf-8") as f:
            self.db = json.load(f)
        self.categories = list(self.db.keys())

        # Flatten items across all categories to build a common vocabulary
        corpus: List[str] = []
        ratings: List[float] = []
        self.items_index = []
        for cat in self.categories:
            items = self.db.get(cat, [])
            for idx, item in enumerate(items):
                text_parts = [
                    item.get("nombre", ""),
                    item.get("reseña", ""),
                    item.get("sinopsis", ""),
                    " ".join(item.get("tags", [])),
                ]
                corpus.append(" ".join(part for part in text_parts if part))
                # Use stored rating if available; otherwise fall back to 0
                calificacion = item.get("calificacion", 0.0)
                # Normalize ratings later with MinMaxScaler
                ratings.append(float(calificacion) if calificacion else 0.0)
                self.items_index.append((cat, idx))

        # Create TF‑IDF matrix
            self.vectorizer = TfidfVectorizer(stop_words=None, max_features=5000)
        self.tfidf_matrix = self.vectorizer.fit_transform(corpus)

        # Normalize ratings to 0–1 range
        ratings_np = np.array(ratings).reshape(-1, 1)
        scaler = MinMaxScaler()
        self.rating_array = scaler.fit_transform(ratings_np).flatten()

    def _get_indices_for_category(self, categoria: str) -> List[int]:
        """Return the list of global indices corresponding to a given category."""
        indices = []
        for global_idx, (cat, idx_in_cat) in enumerate(self.items_index):
            if cat == categoria:
                indices.append(global_idx)
        return indices

    def recommend(
        self,
        categoria: str,
        gustos: List[str],
        method: str = "multimodal",
        top_k: int = 10,
    ) -> List[Dict]:
        """Recommend items for a category given a list of user preferences.

        Parameters
        ----------
        categoria: str
            Category from which to recommend items.
        gustos: List[str]
            List of keywords representing the user's tastes.
        method: str, optional
            One of ``"cbf"``, ``"cf"``, or ``"multimodal"``.  ``cbf`` uses
            only content similarity; ``cf`` returns items sorted by rating;
            ``multimodal`` combines content similarity and normalized ratings.
        top_k: int, optional
            Number of recommendations to return (default is 10).

        Returns
        -------
        List[Dict]
            List of item dictionaries sorted by relevance.
        """
        if categoria not in self.db:
            return []
        gustos_text = " ".join([g.strip().lower() for g in gustos])
        if not gustos_text:
            # If no tastes provided, fallback to top items by rating
            return self.top10(categoria)

        # Compute content similarity
        gustos_vec = self.vectorizer.transform([gustos_text])
        # Filter indices for this category
        cat_indices = self._get_indices_for_category(categoria)
        if not cat_indices:
            return []
        cat_tfidf = self.tfidf_matrix[cat_indices]
        similarity_scores = cosine_similarity(gustos_vec, cat_tfidf).flatten()

        # Normalize similarity scores to 0–1
        sim_norm = (similarity_scores - similarity_scores.min())
        if similarity_scores.max() > 0:
            sim_norm = sim_norm / (similarity_scores.max() - similarity_scores.min())

        # Combine with ratings according to method
        combined_scores = sim_norm.copy()
        if method == "cf":
            combined_scores = self.rating_array[cat_indices]
        elif method == "multimodal":
            rating_scores = self.rating_array[cat_indices]
            # Weighted sum: 0.7 content similarity + 0.3 rating
            combined_scores = 0.7 * sim_norm + 0.3 * rating_scores
        # else: default is cbf, so use sim_norm only

        # Sort indices by score descending
        ranked_indices = np.argsort(combined_scores)[::-1][:top_k]
        recommendations: List[Dict] = []
        for rank_idx in ranked_indices:
            global_idx = cat_indices[rank_idx]
            cat, idx_in_cat = self.items_index[global_idx]
            item = self.db[cat][idx_in_cat]
            recommendations.append(item)
        return recommendations

    def top10(self, categoria: str) -> List[Dict]:
        """Return the top 10 items in a category by rating."""
        items = self.db.get(categoria, [])
        items_sorted = sorted(items, key=lambda x: x.get("calificacion", 0), reverse=True)
        return items_sorted[:10]

    def get_categorias(self) -> List[str]:
        return self.categories.copy()

    def search(self, categoria: str, query: str) -> List[Dict]:
        """Perform a simple case‑insensitive search by name, author or title."""
        items = self.db.get(categoria, [])
        q = query.lower()
        resultados = []
        for item in items:
            if (
                q in item.get("nombre", "").lower()
                or q in item.get("autor", "").lower()
                or q in item.get("titulo", "").lower()
            ):
                resultados.append(item)
        return resultados
